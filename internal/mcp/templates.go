package mcp

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

// ServerTemplate represents an MCP server template
type ServerTemplate struct {
	PackageJSON string
	IndexJS     string
	README      string
}

// ProjectInfo contains information about the project for template generation
type ProjectInfo struct {
	Name      string
	Framework string
	Version   string
	Path      string
}

// GenerateServerFromTemplate creates an MCP server from templates
func GenerateServerFromTemplate(server MCPServer, projectInfo ProjectInfo, mcpDir string) error {
	if err := os.MkdirAll(mcpDir, 0755); err != nil {
		return err
	}

	template := getServerTemplate(server.Framework)
	
	// Generate package.json
	if err := generateFile(mcpDir, "package.json", template.PackageJSON, server, projectInfo); err != nil {
		return fmt.Errorf("failed to generate package.json: %w", err)
	}

	// Generate index.js
	if err := generateFile(mcpDir, "index.js", template.IndexJS, server, projectInfo); err != nil {
		return fmt.Errorf("failed to generate index.js: %w", err)
	}

	// Generate README.md
	if err := generateFile(mcpDir, "README.md", template.README, server, projectInfo); err != nil {
		return fmt.Errorf("failed to generate README.md: %w", err)
	}

	// Make index.js executable
	indexPath := filepath.Join(mcpDir, "index.js")
	return os.Chmod(indexPath, 0755)
}

// generateFile creates a file from a template
func generateFile(dir, filename, templateContent string, server MCPServer, projectInfo ProjectInfo) error {
	tmpl, err := template.New(filename).Parse(templateContent)
	if err != nil {
		return err
	}

	filePath := filepath.Join(dir, filename)
	file, err := os.Create(filePath)
	if err != nil {
		return err
	}
	defer file.Close()

	data := struct {
		Server  MCPServer
		Project ProjectInfo
	}{
		Server:  server,
		Project: projectInfo,
	}

	return tmpl.Execute(file, data)
}

// getServerTemplate returns the template for a specific framework
func getServerTemplate(framework string) ServerTemplate {
	switch framework {
	case "laravel":
		return getLaravelTemplate()
	case "django":
		return getDjangoTemplate()
	default:
		return getUniversalTemplate(framework)
	}
}

// getLaravelTemplate returns Laravel-specific MCP server template
func getLaravelTemplate() ServerTemplate {
	return ServerTemplate{
		PackageJSON: laravelPackageJSON,
		IndexJS:     laravelIndexJS,
		README:      laravelREADME,
	}
}

// getDjangoTemplate returns Django-specific MCP server template
func getDjangoTemplate() ServerTemplate {
	return ServerTemplate{
		PackageJSON: djangoPackageJSON,
		IndexJS:     djangoIndexJS,
		README:      djangoREADME,
	}
}

// getUniversalTemplate returns a universal MCP server template
func getUniversalTemplate(framework string) ServerTemplate {
	return ServerTemplate{
		PackageJSON: strings.ReplaceAll(universalPackageJSON, "{{.Framework}}", framework),
		IndexJS:     strings.ReplaceAll(universalIndexJS, "{{.Framework}}", framework),
		README:      strings.ReplaceAll(universalREADME, "{{.Framework}}", framework),
	}
}

// Template constants
const laravelPackageJSON = `{
  "name": "{{.Server.Name}}",
  "version": "1.0.0",
  "description": "{{.Server.Description}}",
  "main": "index.js",
  "bin": {
    "{{.Server.Name}}": "./index.js"
  },
  "dependencies": {
    "@modelcontextprotocol/sdk": "^1.0.0",
    "@types/node": "^20.0.0"
  },
  "engines": {
    "node": ">=18"
  },
  "keywords": ["mcp", "laravel", "php", "steele"]
}`

const laravelIndexJS = `#!/usr/bin/env node

/**
 * {{.Server.Name}} - Laravel MCP Server
 * Generated by Steele for project: {{.Project.Name}}
 */

const { Server } = require('@modelcontextprotocol/sdk/server/index.js');
const { StdioServerTransport } = require('@modelcontextprotocol/sdk/server/stdio.js');
const { 
  CallToolRequestSchema, 
  ListToolsRequestSchema,
  ListResourcesRequestSchema,
  ReadResourceRequestSchema
} = require('@modelcontextprotocol/sdk/types.js');
const fs = require('fs').promises;
const path = require('path');
const { exec } = require('child_process');
const { promisify } = require('util');

const execAsync = promisify(exec);

class LaravelMCPServer {
  constructor() {
    this.server = new Server(
      {
        name: '{{.Server.Name}}',
        version: '1.0.0',
      },
      {
        capabilities: {
          tools: {},
          resources: {},
        },
      }
    );

    this.projectRoot = '{{.Project.Path}}';
    this.srcPath = path.join(this.projectRoot, 'src');
    this.setupHandlers();
  }

  setupHandlers() {
    // Tools
    this.server.setRequestHandler(ListToolsRequestSchema, async () => ({
      tools: [
        {
          name: 'artisan',
          description: 'Run Laravel Artisan commands',
          inputSchema: {
            type: 'object',
            properties: {
              command: { type: 'string', description: 'Artisan command to run' },
              args: { type: 'array', items: { type: 'string' }, description: 'Command arguments' }
            },
            required: ['command']
          }
        },
        {
          name: 'create_model',
          description: 'Create a new Laravel Eloquent model',
          inputSchema: {
            type: 'object',
            properties: {
              name: { type: 'string', description: 'Model name' },
              migration: { type: 'boolean', description: 'Create migration file' },
              factory: { type: 'boolean', description: 'Create factory file' }
            },
            required: ['name']
          }
        },
        {
          name: 'create_controller',
          description: 'Create a new Laravel controller',
          inputSchema: {
            type: 'object',
            properties: {
              name: { type: 'string', description: 'Controller name' },
              resource: { type: 'boolean', description: 'Create resource controller' },
              api: { type: 'boolean', description: 'Create API controller' }
            },
            required: ['name']
          }
        },
        {
          name: 'run_migration',
          description: 'Run Laravel database migrations',
          inputSchema: {
            type: 'object',
            properties: {
              step: { type: 'number', description: 'Number of migrations to run' },
              rollback: { type: 'boolean', description: 'Rollback migrations' }
            }
          }
        },
        {
          name: 'composer_install',
          description: 'Install Composer dependencies',
          inputSchema: {
            type: 'object',
            properties: {
              dev: { type: 'boolean', description: 'Install dev dependencies' }
            }
          }
        }
      ]
    }));

    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
      try {
        switch (request.params.name) {
          case 'artisan':
            return await this.runArtisan(request.params.arguments);
          case 'create_model':
            return await this.createModel(request.params.arguments);
          case 'create_controller':
            return await this.createController(request.params.arguments);
          case 'run_migration':
            return await this.runMigration(request.params.arguments);
          case 'composer_install':
            return await this.composerInstall(request.params.arguments);
          default:
            throw new Error(` + "`Unknown tool: ${request.params.name}`" + `);
        }
      } catch (error) {
        return {
          content: [{ type: 'text', text: ` + "`Error: ${error.message}`" + ` }],
          isError: true
        };
      }
    });

    // Resources
    this.server.setRequestHandler(ListResourcesRequestSchema, async () => ({
      resources: [
        {
          uri: 'file://routes/web.php',
          name: 'Web Routes',
          description: 'Laravel web routes configuration'
        },
        {
          uri: 'file://routes/api.php',
          name: 'API Routes', 
          description: 'Laravel API routes configuration'
        },
        {
          uri: 'file://config/app.php',
          name: 'App Configuration',
          description: 'Main Laravel application configuration'
        },
        {
          uri: 'file://.env',
          name: 'Environment Configuration',
          description: 'Environment variables and configuration'
        }
      ]
    }));

    this.server.setRequestHandler(ReadResourceRequestSchema, async (request) => {
      const uri = request.params.uri;
      const filePath = uri.replace('file://', '');
      const fullPath = path.join(this.srcPath, filePath);

      try {
        const content = await fs.readFile(fullPath, 'utf-8');
        return {
          contents: [
            {
              uri: request.params.uri,
              mimeType: 'text/plain',
              text: content
            }
          ]
        };
      } catch (error) {
        throw new Error(` + "`Failed to read ${filePath}: ${error.message}`" + `);
      }
    });
  }

  async runArtisan(args) {
    const command = args.command;
    const cmdArgs = args.args || [];
    const fullCommand = ` + "`php artisan ${command} ${cmdArgs.join(' ')}`" + `;

    const { stdout, stderr } = await execAsync(fullCommand, { cwd: this.srcPath });
    
    return {
      content: [
        { type: 'text', text: ` + "`Command: ${fullCommand}\n\nOutput:\n${stdout}\n${stderr ? 'Errors:\n' + stderr : ''}`" + ` }
      ]
    };
  }

  async createModel(args) {
    const name = args.name;
    const migration = args.migration ? '--migration' : '';
    const factory = args.factory ? '--factory' : '';
    
    const command = ` + "`php artisan make:model ${name} ${migration} ${factory}`" + `;
    const { stdout, stderr } = await execAsync(command, { cwd: this.srcPath });

    return {
      content: [
        { type: 'text', text: ` + "`Created model: ${name}\n\nOutput:\n${stdout}\n${stderr ? 'Errors:\n' + stderr : ''}`" + ` }
      ]
    };
  }

  async createController(args) {
    const name = args.name;
    const resource = args.resource ? '--resource' : '';
    const api = args.api ? '--api' : '';
    
    const command = ` + "`php artisan make:controller ${name} ${resource} ${api}`" + `;
    const { stdout, stderr } = await execAsync(command, { cwd: this.srcPath });

    return {
      content: [
        { type: 'text', text: ` + "`Created controller: ${name}\n\nOutput:\n${stdout}\n${stderr ? 'Errors:\n' + stderr : ''}`" + ` }
      ]
    };
  }

  async runMigration(args) {
    let command = 'php artisan migrate';
    
    if (args.rollback) {
      command = 'php artisan migrate:rollback';
      if (args.step) {
        command += ` + "` --step=${args.step}`" + `;
      }
    } else if (args.step) {
      command += ` + "` --step=${args.step}`" + `;
    }

    const { stdout, stderr } = await execAsync(command, { cwd: this.srcPath });

    return {
      content: [
        { type: 'text', text: ` + "`Migration command: ${command}\n\nOutput:\n${stdout}\n${stderr ? 'Errors:\n' + stderr : ''}`" + ` }
      ]
    };
  }

  async composerInstall(args) {
    const dev = args.dev ? '--dev' : '';
    const command = ` + "`composer install ${dev}`" + `;
    
    const { stdout, stderr } = await execAsync(command, { cwd: this.srcPath });

    return {
      content: [
        { type: 'text', text: ` + "`Composer command: ${command}\n\nOutput:\n${stdout}\n${stderr ? 'Errors:\n' + stderr : ''}`" + ` }
      ]
    };
  }

  async run() {
    const transport = new StdioServerTransport();
    await this.server.connect(transport);
    console.error('Laravel MCP Server running on stdio');
  }
}

if (require.main === module) {
  const server = new LaravelMCPServer();
  server.run().catch(console.error);
}

module.exports = LaravelMCPServer;`

const laravelREADME = `# {{.Server.Name}}

{{.Server.Description}}

Generated by Steele for Laravel project: **{{.Project.Name}}**

## Features

- **Artisan Commands**: Run any Laravel Artisan command
- **Model Generation**: Create Eloquent models with migrations and factories
- **Controller Generation**: Create controllers (resource, API, etc.)
- **Migration Management**: Run and rollback database migrations
- **Composer Integration**: Install dependencies
- **File Access**: Read Laravel configuration and route files

## Usage

This MCP server is automatically configured for use with Claude Code. Add the following to your MCP settings:

` + "```json" + `
{
  "{{.Server.Name}}": {
    "command": "node",
    "args": ["ai/mcp-server/index.js"],
    "cwd": "{{.Project.Path}}"
  }
}
` + "```" + `

## Available Tools

- ` + "`artisan`" + ` - Run Laravel Artisan commands
- ` + "`create_model`" + ` - Create new Eloquent models
- ` + "`create_controller`" + ` - Create new controllers
- ` + "`run_migration`" + ` - Run database migrations
- ` + "`composer_install`" + ` - Install Composer dependencies

## Available Resources

- Web Routes (` + "`routes/web.php`" + `)
- API Routes (` + "`routes/api.php`" + `)
- App Configuration (` + "`config/app.php`" + `)
- Environment Configuration (` + "`.env`" + `)

---

*This MCP server was automatically generated by Steele based on your Laravel project structure.*`

const djangoPackageJSON = `{
  "name": "{{.Server.Name}}",
  "version": "1.0.0", 
  "description": "{{.Server.Description}}",
  "main": "index.js",
  "bin": {
    "{{.Server.Name}}": "./index.js"
  },
  "dependencies": {
    "@modelcontextprotocol/sdk": "^1.0.0",
    "@types/node": "^20.0.0"
  },
  "engines": {
    "node": ">=18"
  },
  "keywords": ["mcp", "django", "python", "steele"]
}`

const djangoIndexJS = `#!/usr/bin/env node

/**
 * {{.Server.Name}} - Django MCP Server
 * Generated by Steele for project: {{.Project.Name}}
 */

const { Server } = require('@modelcontextprotocol/sdk/server/index.js');
const { StdioServerTransport } = require('@modelcontextprotocol/sdk/server/stdio.js');
const { 
  CallToolRequestSchema, 
  ListToolsRequestSchema,
  ListResourcesRequestSchema,
  ReadResourceRequestSchema
} = require('@modelcontextprotocol/sdk/types.js');
const fs = require('fs').promises;
const path = require('path');
const { exec } = require('child_process');
const { promisify } = require('util');

const execAsync = promisify(exec);

class DjangoMCPServer {
  constructor() {
    this.server = new Server(
      {
        name: '{{.Server.Name}}',
        version: '1.0.0',
      },
      {
        capabilities: {
          tools: {},
          resources: {},
        },
      }
    );

    this.projectRoot = '{{.Project.Path}}';
    this.srcPath = path.join(this.projectRoot, 'src');
    this.setupHandlers();
  }

  setupHandlers() {
    // Tools
    this.server.setRequestHandler(ListToolsRequestSchema, async () => ({
      tools: [
        {
          name: 'manage',
          description: 'Run Django management commands',
          inputSchema: {
            type: 'object',
            properties: {
              command: { type: 'string', description: 'Management command to run' },
              args: { type: 'array', items: { type: 'string' }, description: 'Command arguments' }
            },
            required: ['command']
          }
        },
        {
          name: 'create_app',
          description: 'Create a new Django app',
          inputSchema: {
            type: 'object',
            properties: {
              name: { type: 'string', description: 'App name' }
            },
            required: ['name']
          }
        },
        {
          name: 'create_model',
          description: 'Create a new Django model',
          inputSchema: {
            type: 'object',
            properties: {
              app: { type: 'string', description: 'App name' },
              name: { type: 'string', description: 'Model name' },
              fields: { type: 'array', items: { type: 'string' }, description: 'Model fields' }
            },
            required: ['app', 'name']
          }
        },
        {
          name: 'run_migration',
          description: 'Run Django database migrations',
          inputSchema: {
            type: 'object',
            properties: {
              app: { type: 'string', description: 'Specific app to migrate' },
              fake: { type: 'boolean', description: 'Mark migrations as run without executing' }
            }
          }
        },
        {
          name: 'create_superuser',
          description: 'Create Django superuser',
          inputSchema: {
            type: 'object',
            properties: {
              username: { type: 'string', description: 'Username' },
              email: { type: 'string', description: 'Email address' }
            },
            required: ['username', 'email']
          }
        }
      ]
    }));

    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
      try {
        switch (request.params.name) {
          case 'manage':
            return await this.runManage(request.params.arguments);
          case 'create_app':
            return await this.createApp(request.params.arguments);
          case 'create_model':
            return await this.createModel(request.params.arguments);
          case 'run_migration':
            return await this.runMigration(request.params.arguments);
          case 'create_superuser':
            return await this.createSuperuser(request.params.arguments);
          default:
            throw new Error(` + "`Unknown tool: ${request.params.name}`" + `);
        }
      } catch (error) {
        return {
          content: [{ type: 'text', text: ` + "`Error: ${error.message}`" + ` }],
          isError: true
        };
      }
    });

    // Resources
    this.server.setRequestHandler(ListResourcesRequestSchema, async () => ({
      resources: [
        {
          uri: 'file://manage.py',
          name: 'Django Management',
          description: 'Django management script'
        },
        {
          uri: 'file://settings.py',
          name: 'Django Settings',
          description: 'Django project settings'
        },
        {
          uri: 'file://urls.py',
          name: 'URL Configuration',
          description: 'Django URL routing configuration'
        },
        {
          uri: 'file://requirements.txt',
          name: 'Python Dependencies',
          description: 'Python package requirements'
        }
      ]
    }));

    this.server.setRequestHandler(ReadResourceRequestSchema, async (request) => {
      const uri = request.params.uri;
      const filePath = uri.replace('file://', '');
      const fullPath = path.join(this.srcPath, filePath);

      try {
        const content = await fs.readFile(fullPath, 'utf-8');
        return {
          contents: [
            {
              uri: request.params.uri,
              mimeType: 'text/plain',
              text: content
            }
          ]
        };
      } catch (error) {
        throw new Error(` + "`Failed to read ${filePath}: ${error.message}`" + `);
      }
    });
  }

  async runManage(args) {
    const command = args.command;
    const cmdArgs = args.args || [];
    const fullCommand = ` + "`python manage.py ${command} ${cmdArgs.join(' ')}`" + `;

    const { stdout, stderr } = await execAsync(fullCommand, { cwd: this.srcPath });
    
    return {
      content: [
        { type: 'text', text: ` + "`Command: ${fullCommand}\n\nOutput:\n${stdout}\n${stderr ? 'Errors:\n' + stderr : ''}`" + ` }
      ]
    };
  }

  async createApp(args) {
    const name = args.name;
    const command = ` + "`python manage.py startapp ${name}`" + `;
    
    const { stdout, stderr } = await execAsync(command, { cwd: this.srcPath });

    return {
      content: [
        { type: 'text', text: ` + "`Created Django app: ${name}\n\nOutput:\n${stdout}\n${stderr ? 'Errors:\n' + stderr : ''}`" + ` }
      ]
    };
  }

  async createModel(args) {
    // This would generate model code - simplified for now
    const app = args.app;
    const name = args.name;
    const fields = args.fields || [];

    return {
      content: [
        { type: 'text', text: ` + "`Model creation planned for ${name} in app ${app} with fields: ${fields.join(', ')}\n\nNote: Manual model creation required in ${app}/models.py`" + ` }
      ]
    };
  }

  async runMigration(args) {
    let command = 'python manage.py migrate';
    
    if (args.app) {
      command += ` + "` ${args.app}`" + `;
    }
    
    if (args.fake) {
      command += ' --fake';
    }

    const { stdout, stderr } = await execAsync(command, { cwd: this.srcPath });

    return {
      content: [
        { type: 'text', text: ` + "`Migration command: ${command}\n\nOutput:\n${stdout}\n${stderr ? 'Errors:\n' + stderr : ''}`" + ` }
      ]
    };
  }

  async createSuperuser(args) {
    const username = args.username;
    const email = args.email;
    
    // Use DJANGO_SUPERUSER_* environment variables for non-interactive creation
    const env = {
      ...process.env,
      DJANGO_SUPERUSER_USERNAME: username,
      DJANGO_SUPERUSER_EMAIL: email,
      DJANGO_SUPERUSER_PASSWORD: 'admin123' // Default password
    };
    
    const command = 'python manage.py createsuperuser --noinput';
    const { stdout, stderr } = await execAsync(command, { cwd: this.srcPath, env });

    return {
      content: [
        { type: 'text', text: ` + "`Created superuser: ${username}\nEmail: ${email}\nDefault password: admin123\n\nOutput:\n${stdout}\n${stderr ? 'Errors:\n' + stderr : ''}`" + ` }
      ]
    };
  }

  async run() {
    const transport = new StdioServerTransport();
    await this.server.connect(transport);
    console.error('Django MCP Server running on stdio');
  }
}

if (require.main === module) {
  const server = new DjangoMCPServer();
  server.run().catch(console.error);
}

module.exports = DjangoMCPServer;`

const djangoREADME = `# {{.Server.Name}}

{{.Server.Description}}

Generated by Steele for Django project: **{{.Project.Name}}**

## Features

- **Management Commands**: Run any Django management command
- **App Creation**: Create new Django apps
- **Model Management**: Create and manage Django models
- **Migration Management**: Run database migrations
- **User Management**: Create superusers
- **File Access**: Read Django configuration and settings

## Usage

This MCP server is automatically configured for use with Claude Code. Add the following to your MCP settings:

` + "```json" + `
{
  "{{.Server.Name}}": {
    "command": "node",
    "args": ["ai/mcp-server/index.js"],
    "cwd": "{{.Project.Path}}"
  }
}
` + "```" + `

## Available Tools

- ` + "`manage`" + ` - Run Django management commands
- ` + "`create_app`" + ` - Create new Django apps
- ` + "`create_model`" + ` - Create new models
- ` + "`run_migration`" + ` - Run database migrations
- ` + "`create_superuser`" + ` - Create Django superusers

## Available Resources

- Management Script (` + "`manage.py`" + `)
- Django Settings (` + "`settings.py`" + `)
- URL Configuration (` + "`urls.py`" + `)
- Python Dependencies (` + "`requirements.txt`" + `)

---

*This MCP server was automatically generated by Steele based on your Django project structure.*`

const universalPackageJSON = `{
  "name": "{{.Server.Name}}",
  "version": "1.0.0",
  "description": "{{.Server.Description}}",
  "main": "index.js",
  "bin": {
    "{{.Server.Name}}": "./index.js"
  },
  "dependencies": {
    "@modelcontextprotocol/sdk": "^1.0.0",
    "@types/node": "^20.0.0"
  },
  "engines": {
    "node": ">=18"
  },
  "keywords": ["mcp", "{{.Framework}}", "steele"]
}`

const universalIndexJS = `#!/usr/bin/env node

/**
 * {{.Server.Name}} - {{.Framework}} MCP Server
 * Generated by Steele for project: {{.Project.Name}}
 */

const { Server } = require('@modelcontextprotocol/sdk/server/index.js');
const { StdioServerTransport } = require('@modelcontextprotocol/sdk/server/stdio.js');
const { 
  CallToolRequestSchema, 
  ListToolsRequestSchema,
  ListResourcesRequestSchema,
  ReadResourceRequestSchema
} = require('@modelcontextprotocol/sdk/types.js');
const fs = require('fs').promises;
const path = require('path');
const { exec } = require('child_process');
const { promisify } = require('util');

const execAsync = promisify(exec);

class UniversalMCPServer {
  constructor() {
    this.server = new Server(
      {
        name: '{{.Server.Name}}',
        version: '1.0.0',
      },
      {
        capabilities: {
          tools: {},
          resources: {},
        },
      }
    );

    this.projectRoot = '{{.Project.Path}}';
    this.srcPath = path.join(this.projectRoot, 'src');
    this.setupHandlers();
  }

  setupHandlers() {
    // Basic tools
    this.server.setRequestHandler(ListToolsRequestSchema, async () => ({
      tools: [
        {
          name: 'run_command',
          description: 'Run shell commands in the project directory',
          inputSchema: {
            type: 'object',
            properties: {
              command: { type: 'string', description: 'Command to run' },
              args: { type: 'array', items: { type: 'string' }, description: 'Command arguments' }
            },
            required: ['command']
          }
        },
        {
          name: 'list_files',
          description: 'List files in project directory',
          inputSchema: {
            type: 'object',
            properties: {
              directory: { type: 'string', description: 'Directory to list (relative to project root)' }
            }
          }
        }
      ]
    }));

    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
      try {
        switch (request.params.name) {
          case 'run_command':
            return await this.runCommand(request.params.arguments);
          case 'list_files':
            return await this.listFiles(request.params.arguments);
          default:
            throw new Error(` + "`Unknown tool: ${request.params.name}`" + `);
        }
      } catch (error) {
        return {
          content: [{ type: 'text', text: ` + "`Error: ${error.message}`" + ` }],
          isError: true
        };
      }
    });

    // Basic resources
    this.server.setRequestHandler(ListResourcesRequestSchema, async () => ({
      resources: [
        {
          uri: 'file://package.json',
          name: 'Package Configuration',
          description: 'Project package configuration'
        },
        {
          uri: 'file://README.md',
          name: 'Project README',
          description: 'Project documentation'
        }
      ]
    }));

    this.server.setRequestHandler(ReadResourceRequestSchema, async (request) => {
      const uri = request.params.uri;
      const filePath = uri.replace('file://', '');
      const fullPath = path.join(this.srcPath, filePath);

      try {
        const content = await fs.readFile(fullPath, 'utf-8');
        return {
          contents: [
            {
              uri: request.params.uri,
              mimeType: 'text/plain',
              text: content
            }
          ]
        };
      } catch (error) {
        throw new Error(` + "`Failed to read ${filePath}: ${error.message}`" + `);
      }
    });
  }

  async runCommand(args) {
    const command = args.command;
    const cmdArgs = args.args || [];
    const fullCommand = ` + "`${command} ${cmdArgs.join(' ')}`" + `;

    const { stdout, stderr } = await execAsync(fullCommand, { cwd: this.srcPath });
    
    return {
      content: [
        { type: 'text', text: ` + "`Command: ${fullCommand}\n\nOutput:\n${stdout}\n${stderr ? 'Errors:\n' + stderr : ''}`" + ` }
      ]
    };
  }

  async listFiles(args) {
    const directory = args.directory || '.';
    const targetPath = path.join(this.srcPath, directory);
    
    try {
      const files = await fs.readdir(targetPath, { withFileTypes: true });
      const fileList = files.map(file => ({
        name: file.name,
        type: file.isDirectory() ? 'directory' : 'file'
      }));

      return {
        content: [
          { type: 'text', text: ` + "`Files in ${directory}:\n\n${fileList.map(f => `${f.type === 'directory' ? 'üìÅ' : 'üìÑ'} ${f.name}`).join('\n')}`" + ` }
        ]
      };
    } catch (error) {
      throw new Error(` + "`Failed to list files in ${directory}: ${error.message}`" + `);
    }
  }

  async run() {
    const transport = new StdioServerTransport();
    await this.server.connect(transport);
    console.error('{{.Framework}} MCP Server running on stdio');
  }
}

if (require.main === module) {
  const server = new UniversalMCPServer();
  server.run().catch(console.error);
}

module.exports = UniversalMCPServer;`

const universalREADME = `# {{.Server.Name}}

{{.Server.Description}}

Generated by Steele for {{.Framework}} project: **{{.Project.Name}}**

## Features

- **Command Execution**: Run shell commands in the project directory
- **File Management**: List and explore project files
- **File Access**: Read project configuration and documentation

## Usage

This MCP server is automatically configured for use with Claude Code. Add the following to your MCP settings:

` + "```json" + `
{
  "{{.Server.Name}}": {
    "command": "node",
    "args": ["ai/mcp-server/index.js"],
    "cwd": "{{.Project.Path}}"
  }
}
` + "```" + `

## Available Tools

- ` + "`run_command`" + ` - Run shell commands in the project
- ` + "`list_files`" + ` - List files and directories

## Available Resources

- Package Configuration (` + "`package.json`" + `)
- Project README (` + "`README.md`" + `)

---

*This MCP server was automatically generated by Steele based on your {{.Framework}} project structure.*`