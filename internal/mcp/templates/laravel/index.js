#!/usr/bin/env node

/**
 * {{.Server.Name}} - Laravel MCP Server
 * Generated by Atempo for project: {{.Project.Name}}
 */

const { Server } = require('@modelcontextprotocol/sdk/server/index.js');
const { StdioServerTransport } = require('@modelcontextprotocol/sdk/server/stdio.js');
const { 
  CallToolRequestSchema, 
  ListToolsRequestSchema,
  ListResourcesRequestSchema,
  ReadResourceRequestSchema
} = require('@modelcontextprotocol/sdk/types.js');
const fs = require('fs').promises;
const path = require('path');
const { exec } = require('child_process');
const { promisify } = require('util');

const execAsync = promisify(exec);

class LaravelMCPServer {
  constructor() {
    this.server = new Server(
      {
        name: '{{.Server.Name}}',
        version: '1.0.0',
      },
      {
        capabilities: {
          tools: {},
          resources: {},
        },
      }
    );

    this.projectRoot = '{{.Project.Path}}';
    this.srcPath = path.join(this.projectRoot, 'src');
    this.setupHandlers();
  }

  setupHandlers() {
    // Tools
    this.server.setRequestHandler(ListToolsRequestSchema, async () => ({
      tools: [
        {
          name: 'artisan',
          description: 'Run Laravel Artisan commands',
          inputSchema: {
            type: 'object',
            properties: {
              command: { type: 'string', description: 'Artisan command to run' },
              args: { type: 'array', items: { type: 'string' }, description: 'Command arguments' }
            },
            required: ['command']
          }
        }
      ]
    }));

    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
      try {
        switch (request.params.name) {
          case 'artisan':
            return await this.runArtisan(request.params.arguments);
          default:
            throw new Error(`Unknown tool: ${request.params.name}`);
        }
      } catch (error) {
        return {
          content: [{ type: 'text', text: `Error: ${error.message}` }],
          isError: true
        };
      }
    });

    // Resources
    this.server.setRequestHandler(ListResourcesRequestSchema, async () => ({
      resources: [
        {
          uri: 'file://routes/web.php',
          name: 'Web Routes',
          description: 'Laravel web routes configuration'
        },
        {
          uri: 'file://config/app.php',
          name: 'App Configuration',
          description: 'Main Laravel application configuration'
        }
      ]
    }));

    this.server.setRequestHandler(ReadResourceRequestSchema, async (request) => {
      const uri = request.params.uri;
      const filePath = uri.replace('file://', '');
      const fullPath = path.join(this.srcPath, filePath);

      try {
        const content = await fs.readFile(fullPath, 'utf-8');
        return {
          contents: [
            {
              uri: request.params.uri,
              mimeType: 'text/plain',
              text: content
            }
          ]
        };
      } catch (error) {
        throw new Error(`Failed to read ${filePath}: ${error.message}`);
      }
    });
  }

  async runArtisan(args) {
    const command = args.command;
    const cmdArgs = args.args || [];
    const fullCommand = `php artisan ${command} ${cmdArgs.join(' ')}`;

    const { stdout, stderr } = await execAsync(fullCommand, { cwd: this.srcPath });
    
    return {
      content: [
        { type: 'text', text: `Command: ${fullCommand}\n\nOutput:\n${stdout}\n${stderr ? 'Errors:\n' + stderr : ''}` }
      ]
    };
  }

  async run() {
    const transport = new StdioServerTransport();
    await this.server.connect(transport);
    console.error('Laravel MCP Server running on stdio');
  }
}

if (require.main === module) {
  const server = new LaravelMCPServer();
  server.run().catch(console.error);
}

module.exports = LaravelMCPServer;